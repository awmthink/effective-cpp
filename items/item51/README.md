# Item 51: 编写new和delete时需要固守常规

* operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理 0 bytes 申请。Class专属版本则还应该处理，“比正确大小更大（错误）申请”。
* operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大（错误）申请”。

Class专属版本需要特定处理的问题，是考虑到它的派生类的问题，我们的定制是针对Base来实现的，并不适合派生类，所以要能够识别到，如果是派生类，则调用全局的分配与释放函数。我们可以通过`sizeof`来判定类的的大小，但这个方法不适合数组的申请与释放，因为数组的申请时，我们拿到的数组的大小，无法计算对象的大小。

因此，你不能在`Base::operator new[]`内假设 `array` 的每个元素对象的大小是`sizeof(Base)`，这也就意味你不能假设 `array` 的元素对象个数是 `(bytes 申请数)/sizeof(Base)`。此外，传递给 `operator new[]`的 `size_t`参数，其值有可能比“将被填以对象”的内存数量更多，因为条款 16 说过，动态分配的 arrays 可能包含额外空间用来存放元素个数。