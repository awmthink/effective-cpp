# Item 29: 为“异常安全”而努力是值得的

* 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数分为三种可能的保证：基本型、强烈型、不抛异常型。
* 强烈保证往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。
* 函数提供的“异常全全保证”通常最高只等于其所调用的各个函数的“异常全安保证”中的最弱者。

当我们在讨论函数是否“异常安全”时，一般是指函数执行过程中，如果抛出了异常，能满足以下2个条件：

1. 不泄漏任何资源。包括了内存、文件句柄、锁、线程句柄等。
2. 不允许数据败坏。比如对一些数据对像的修改，不能修改到一半，或对一些资源进行了释放，但没有赋予新的合理的值。

```cpp
class PrettyMenu {
public:
    void changeBackground(std::istream& imgSrc); // 改变背景图像
private:
    Mutex mutex;            // 互斥器
    Image* bgImage;         // 目前的背景图像
    int  imageChanges;      // 背景图像改变的次数
};

void PrettyMenu::changeBackground(std::istream& imgSrc) {
    lock(&mutex);
    delete bgImage;
    ++imageChanges;
    bgImage = new Image(imgSrc);
    unlock(&mutex);
}
```

如果从异常安全性的角度来看，`changeBackground`函数没有一个条件能满足，因为在`new Image(imgSrc)`这条语句里，有可能因为`Image`的构造函数或`new`表达式而抛出异常。当抛出异常时，mutex这个锁资源并没有释放，另外PrettyMenu这个对象也处于不完整的一个状态。

对于资源泄漏的问题，一般比较容易解决，我们利用RAII，把资源装到一个资源管理的对象中。但对于执行中败坏数据的问题，有时是比较难以解决的，比如我们从`istream`中读取数据，就修改了`istream`内部的状态，这个状态是很难复原的。

异常安全函数的三种等级保证。

* **基本承诺**：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态(例如所有的 class 约束条件都继续获得满足)。然而程序的现实状态(exact state)恐怕不可预料。举个例子，我们可以撰写 changeBackground使得一旦有异常被抛出时，PrettyMenu对象可以继续拥有原背景图像，或是令它拥有某个缺省背景图像，但客户无法预期哪一种情况。如果想知道，他们恐怕必须调用某个成员函数以得知当时的背景图像是什么。

* **强烈保证**：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知:如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。它和基本承诺不同在于，基本承诺只保证出现异常时，程序处理一个合法状态，但这个合法状态不一定如我们的期望。

* **不抛异常保证**：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。只所有可以声明完全不抛异常是因为：内置类型（int，指针等）身上的所有操作都是提供nothrow保证的。但不抛异常保证，只是一个声明上的保证，实际执行时，这个函数会不会抛出异常是不确定的，取决于函数的实现，目前编译器还检测不出来对这种承诺的违反。

