# Item 08: 别让异常逃离析构函数

* 析构函数不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应用捕捉任何异常，然后吞下它们（不传播）或结束程序。
* 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供普通函数（而非在析构函数中）执行该操作。

```cpp
class DBConn {
 public:
  void close() {
    db.close();
    closed = true;
  }
  ~DBConn() {
    if (!closed) {
      try {
        db.close();
      } catch (...) {
        // 制作运转记录，记下对close的调用失败
      }
    }
  }

 private:
  bool closed;
  DBConnection db;
};
```


在C++中，不应该让析构函数中抛出异常。这是因为当一个对象被销毁时，C++运行时系统会自动调用其析构函数，此时如果析构函数抛出了异常，那么程序就会终止，而且可能会导致资源泄漏。

当一个对象被销毁时，它的成员变量和父类对象会先被销毁，然后再销毁自身。如果在成员变量或父类对象的析构函数中抛出了异常，那么当前对象的析构函数就不会被执行，从而导致资源泄漏。此外，如果析构函数抛出了异常，那么程序可能会进入一种不确定的状态，因为其他对象的析构函数也可能会因为当前对象的析构函数抛出异常而不被执行。

栈展开（stack unwinding）是一种处理异常的机制，它可以在出现异常时，按照函数调用的反向顺序执行析构函数，从而释放资源。这个机制可以处理析构函数中抛出的异常，但并不能完全解决这个问题。

当一个对象被销毁时，C++运行时系统会自动调用其析构函数。如果在析构函数中抛出了异常，那么栈展开机制会按照函数调用的反向顺序执行析构函数，直到找到一个能够处理这个异常的catch块。如果找不到这样的catch块，程序就会调用terminate函数终止运行。

栈展开可以处理析构函数异常的问题吗？

虽然栈展开机制可以处理析构函数中的异常，但它并不能完全解决这个问题。因为如果多个对象的析构函数都抛出了异常，那么栈展开机制会按照函数调用的反向顺序执行析构函数，但只会处理第一个抛出异常的析构函数，对于其他抛出异常的析构函数，它们的异常就会被忽略。这个问题也被称为“悬垂指针”（dangling pointer）的问题，因为可能会有一些资源没有被释放，导致出现悬垂指针。

```cpp
void func() {
  A a;
  B b;
  destory(a) // a的析构函数
  destory(b) // b的构函数
}

void destroy(object) {
  throw "exception";
}
```
推演一下：在`func`的调用中，`destory(a)`时会发生异常，这时进行栈展开，会继续销毁`b`，但`b`销毁时又发生了异常，这里相当于在栈展开时发生了异常，C++就不处理了。

[main.cc](./main.cc)代码中`std::vector<Widget>`的销毁会遇到同样的问题。

