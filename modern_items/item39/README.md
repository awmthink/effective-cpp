# Item 39: 对于一次性事件通信考虑使用`void`的`futures`

* 基于简单的事件通信，基于条件变量的设计需要一个多余的互斥锁，对检测和反应任务的相对进度有约束，并且需要反应任务来验证事件是否已发生。
* 基于flag的设计避免了上一条的问题，但是是基于轮询的，而不是阻塞
* 条件变量和flag可以组合命名用，但产生的通信机制很不自然
* 使用`std::promise`和`future`的方案避开了这些问题，但这个方法使用了堆内存存储共享状态，同时只能有只能使用一次通信的限制


在C++20中，应该可以使用原子变量的`wait`的接口，以及信号量的`acquire/release`来实现。